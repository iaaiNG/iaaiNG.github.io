<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web安全]]></title>
    <url>%2F2019%2F04%2F02%2F16-Web%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[安全是一个非常重要的话题，非常有必要了解其攻击的原理和防范的方法。 为什么要用 HTTPS HTTP 劫持 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。 例如：网络运营商在正常HTTP请求的数据流中插入精心设计的网络数据报文，让客户端展示“错误”的数据。 HTTPS 优势 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 XSS(跨站脚本攻击) 和 X-XSS-Protection XSS： (Cross Site Scripting)为不和层叠样式表(CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是攻击者利用漏洞，向 Web 页面中注入恶意代码，当用户浏览该页之时，注入的代码会被执行，从而达到攻击的特殊目的。 X-XSS-Protection： HTTP X-XSS-Protection 标头是IE，Chrome和Safari的一个功能，当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面。 CSP CSP(Content Security Policy)内容安全策略。这个规范与内容安全有关，主要是用来定义页面可以加载哪些资源，减少 XSS 的发生。 CSP白名单 作用：告诉客户端允许加载和不允许加载的内容，定义此政策后，浏览器加载来自任何其他来源的脚本，只会引发一个错误。 引入方法 使用meta标签， 直接在页面添加meta标签， 1&lt;meta http-equiv="Content-Security-Policy" content="script-src 'self' https://host1.com https://host2.com"&gt; 点评：每个页面都需要添加，而且不能对限制的域名进行上报，但优先级高。 在服务端配置csp 123Nginx :In your server &#123;&#125; block add:add_header Content-Security-Policy "default-src 'self';"; 点评：在服务端配置所有的页面都可以不需要改了，而且还支持上报。 格式：HTTP标头: 指令 关键字 有效的脚本来源 有效的脚本来源…; CSP指令 base-uri 用于限制可在页面的 元素中显示的网址。 child-src 用于列出适用于工作线程和嵌入的帧内容的网址。例如：child-src https://youtube.com 将启用来自 YouTube（而非其他来源）的嵌入视频。 connect-src 用于限制可（通过 XHR、WebSockets 和 EventSource）连接的来源。 font-src 用于指定可提供网页字体的来源。 form-action 用于列出可从 标记提交的有效端点。 default-src 此指令用于定义您未指定的大多数指令的默认值 sandbox 它限制的是页面可进行的操作，而不是页面可加载的资源 CSP关键字 ‘none’ 不执行任何匹配。 ‘self’ 与当前来源（而不是其子域）匹配。 ‘unsafe-inline’ 允许使用内联 JavaScript 和 CSS。 ‘unsafe-eval’ 允许使用类似 eval 的 text-to-JavaScript 机制。 内联代码和eval()被视为是有害的。 原因：内联代码可以带来XSS攻击。而eval()、new Function()…将不活动文本转换为可执行的 JavaScript，并代表他们执行它。 CSP解决：完全禁止内联脚本；CSP默认阻止eval这些方法。 做法： 内联script标记，改引入外部js文件 用addEventListener()调用，替换元素属性定义事件 不使用eval CSRF(跨站请求伪造) CSRF： 是一种冒充受信任用户，向服务器发送非预期请求的攻击方式。 简单例子： 假如博客园有个加关注的GET接口，blogUserGuid参数很明显是关注人Id，如下： 1http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315 那我只需要在我的一篇博文内容里面写一个img标签： 1&lt;img style="width:0;" src="http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315"/&gt; 那么只要有人打开我这篇博文，那就会自动关注我。 防御CSRF攻击的手段 尽量使用POST，限制GET 加验证码 Anti CSRF Token（推荐） 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，来判断请求是否合法 clickjacking(点击劫持) 和 X-Frame-Options ClickJacking： 点击劫持，是一种视觉上的欺骗手段。 两种攻击方式： 攻击者在原有网页覆盖一个透明的iframe，然后诱使用户在该页面上进行操作。 攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义； 解决： 使用 HTTP X-Frame-Options 标头，配置参数： DENY：浏览器会拒绝当前页面加载任何frame页面； SAMEORIGIN：frame页面的地址只能为同源域名下的页面； ALLOW-FROM origin：允许frame加载的页面地址； 参考 【前端安全】JavaScript防http劫持与XSS：http://www.cnblogs.com/coco1s/p/5777260.html CSP内容安全政策：https://developers.google.cn/web/fundamentals/security/csp/ Web安全之ClickJacking：https://www.cnblogs.com/lovesong/p/5248483.html Web安全之CSRF攻击：https://www.cnblogs.com/lovesong/p/5233195.html]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[互联网协议]]></title>
    <url>%2F2019%2F03%2F28%2F15-%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[为了可以帮助理解：网络优化，服务器访问，ajax请求，http协议等一系列问题，我想需要了解一下互联网协议。 互联网的核心是一系列协议，总称为&quot;互联网协议&quot;（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。 一、概述 互联网的实现，分成好几层。每一层都有自己的功能。用户接触到的，只有最上面的一层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。 应用层： 规定应用程序的数据格式。 传输层： 建立&quot;端口到端口&quot;的通信。 网络层： 引进一套新的地址，使区分不同的子网络。这套地址就叫做IP地址。 链接层： 对&quot;实体层&quot;0和1的电信号进行分组成一个个数据包，让同一子网络的计算机之间进行数据包传输。 实体层： 把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 二、实体层 (1) 背景 计算机之间要组网，要传输数据，需要先把电脑连起来，可以是用光缆、电缆、双绞线、无线电波等方式。 (2) 功能 通过物理手段，把电脑连接起来。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 三、链接层 (1) 背景 单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？ (2) 功能 &quot;链接层&quot;对&quot;实体层&quot;0和1的电信号进行分组，形成一个个数据包，让同一子网络的计算机之间进行数据包传输。 (3) 以太网协议 早期，每家公司分组方式不同。后来，被一种叫&quot;以太网&quot;的协议，占据了主导地位。 分组方式 以太网规定协议规定，一组电信号构成一个数据包，叫做&quot;帧&quot;（Frame）。 每一帧分成两个部分：标头（Head）和数据（Data）。 &quot;标头&quot;包含数据包的一些说明项，比如发送者、接受者、数据类型等等，长度固定为18字节。； &quot;数据&quot;则是数据包的具体内容，长度最短为46字节，最长为1500字节。 因此，整个&quot;帧&quot;最短为64字节，最长为1518字节。不然，就必须分割成多个帧进行发送。 MAC地址 以太网协议规定，连入网络的所有设备，必须都具有&quot;网卡&quot;接口。数据包只能在网卡之间传输。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡的MAC地址是独一无二的。 广播 假如两台主机在同一个子网络，可以通过ARP协议，使以太网数据包知道接收方的MAC地址。（后文有介绍ARP协议） 然后以太网协议将采用&quot;广播&quot;的方式，向同一个子网络内所有计算机发送数据包，让每台计算机自己判断，是否为接收方。 四、网络层 (1) 背景 因为以太网协议以广播的方式传输数据，效率有限，所以只能局限在发送者所在的子网络。为此需要区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用&quot;路由&quot;方式发送。（&quot;路由&quot;的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。） (1) 功能 &quot;网络层&quot;的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做IP地址。 (2) IP协议 IP地址被IP协议所定义。目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。 子网掩码 IP协议规定里的&quot;子网掩码&quot;，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。把IP地址与子网掩码进行&quot;按位与&quot;运算，结果相同的IP地址就属于同一个子网络。 IP数据包 根据IP协议发送的数据，就叫做IP数据包。IP数据包直接放在以太网数据包的&quot;数据&quot;部分，以避免影响以太网数据包的规则。 具体来说，IP数据包也分为&quot;标头&quot;和&quot;数据&quot;两个部分。 &quot;标头&quot;部分主要包括版本、长度、IP地址等信息； &quot;数据&quot;部分则是IP数据包的具体内容。 整个IP数据包的总长度最大为65,535字节。前面说过，以太网数据包的&quot;数据&quot;部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。 ARP协议 因为IP数据包是放在以太网数据包里发送的，所以必须同时对方的MAC地址和IP地址。IP地址可以通过DNS协议获取，但是我们不知道它的MAC地址。 所以，我们需要一种机制，能够从IP地址得到MAC地址。分成以下两种情况。 第一种情况，如果两台主机不在同一个子网络： 如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的&quot;网关&quot;（gateway），让网关去处理。 第二种情况，如果两台主机在同一个子网络： 可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个&quot;广播&quot;地址。 发出数据包所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 五、传输层 (1) 背景 有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做&quot;端口&quot;（port），它其实是每一个使用网卡的程序的编号。 每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。&quot;端口&quot;是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。 (2) 功能 &quot;传输层&quot;的功能，就是建立&quot;端口到端口&quot;的通信。相比之下，&quot;网络层&quot;的功能是建立&quot;主机到主机&quot;的通信。只要确定主机和端口，我们就能实现程序之间的交流。 (3) UDP协议 UDP协议可以在数据包中加入端口信息，UDP数据包，也是由&quot;标头&quot;和&quot;数据&quot;两部分组成。然后，把整个UDP数据包放入IP数据包的&quot;数据&quot;部分，而前面说过，IP数据包又是放在以太网数据包之中。 &quot;标头&quot;部分主要定义了发出端口和接收端口。 &quot;数据&quot;部分就是具体的内容。 UDP数据包，标头&quot;部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。以整个以太网数据包现在变成了下面这样： (4) TCP协议 UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。 为此TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。 TCP数据包和UDP数据包一样，都是内嵌在IP数据包的&quot;数据&quot;部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 六、应用层 (1) 背景 TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。 应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。 (2) 功能 &quot;应用层&quot;的作用，就是规定应用程序的数据格式。这是最高的一层，直接面对用户。它的数据就放在TCP数据包的&quot;数据&quot;部分。因此，现在的以太网的数据包就变成下面这样。 七、一个实例：访问网页 上面是从设计者的角度看问题，下面切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。 (1) 用户首先设置参数 本机的IP地址：192.168.1.100 子网掩码：255.255.255.0 网关的IP地址：192.168.1.1 DNS的IP地址：8.8.8.8 然后，在浏览器地址栏输入了网址：www.google.com。这意味着，浏览器要向Google发送一个网页请求的数据包。 (2) DNS协议 DNS协议可以将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是向这个地址发送一个DNS数据包（53端口）。 DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。 (3) 子网掩码 本机对自己的IP地址192.168.1.100和Google的IP地址172.194.72.105，做按位与运算（两个数位都为1，结果为1，否则为0），两个计算结果显然不相等，所以Google与本机不在同一个子网络。 (4) 应用层协议 浏览网页用的是HTTP协议，假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。 (5) TCP协议 TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。 TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。 (6) IP协议 然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。 IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。 (7) 以太网协议 最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。 以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。 (8) 服务器端响应 经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。 根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的&quot;HTTP请求&quot;，接着做出&quot;HTTP响应&quot;，再用TCP协议发回来。 本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。 补充： (1) 字节概念 字节也叫Byte，是计算机数据的基本存储单位。 8bit(位) = 1Byte(字节) 1024Byte(字节) = 1KB 1024KB = 1MB (2) TCP协议 TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。 TCP 数据包的编号 TCP 负载实际为1400字节左右。一次性发送大量数据，就必须分成多个包。比如，一个 10MB 的文件，需要发送7100多个包。 发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。 第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。 TCP 数据包的组装 收到 TCP 数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。 TCP 并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP 协议就有一个头信息Content-Length，表示信息体的大小。 应用程序收到组装好的原始数据，以浏览器为例，就会根据 HTTP 协议的Content-Length字段正确读出一段段的数据。TCP 数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。 慢启动和 ACK TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。 默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。&quot;确认&quot;的英语是 acknowledgement，所以这个确认消息就简称 ACK。 数据包的遗失处理 每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。 (3) 面试题 从输入 url 到 页面加载 发生了什么 客户端的地址栏输入URL并按下回车。 客户端查找当前URL是否存在缓存，并比较缓存是否过期。 DNS解析URL对应的IP。 根据IP建立TCP连接（三次握手）。 客户端发起HTTP请求。 服务器处理请求，客户端接收服务器响应。 渲染页面，构建DOM树。 关闭TCP连接（四次挥手） 参考 互联网协议入门：http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html TCP协议介绍：http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事件流和事件处理机制]]></title>
    <url>%2F2019%2F03%2F26%2F14-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[什么是模型？ 通过主观意识借助实体或者虚拟表现构成客观阐述形态结构的一种表达目的的物件（物件并不等于物体，不局限于实体与虚拟、不限于平面与立体）。（copy百度百科） 很多文章把事件流也称做事件模型，我觉得不贴切。 模型应该是一个可以想象的物件。而其文中解释的却是事件由监听到触发的过程。所以称之为模型，让人难以理解。称之为流，更为贴切。 一、注册事件监听器 有三种方式可以为DOM元素注册事件处理函数。 (1) HTML 属性 123&lt;button id="btn" onclick="doSomething()"&gt;// 等同于btn.setAttribute('onclick', 'doSomething()'); 使用这个方法指定的监听代码，只会在冒泡阶段触发。 (2) DOM 元素属性 1btn.onclick = doSomethig 使用这个方法指定的监听函数，也是只会在冒泡阶段触发。 (3) EventTarget.addEventListener 1window.addEventListener('load', doSomething, false); 所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。 (4) 小结 第一种方法，违反了HTML与JS代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。 第二种方法的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。 第三种EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点： 同一个事件可以添加多个监听函数。 能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。 除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。 三种监听函数内部的this指向触发事件的那个元素节点。 二、事件的传播 (1) 一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。 第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。 第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。 第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。 (2) DOM事件流在DOM树中调度的事件的图形表示 三、事件的代理 利用事件传播冒泡阶段的特点，可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。 123456var ul = document.querySelector('ul');ul.addEventListener('click', function (event) &#123; if (event.target.tagName.toLowerCase() === 'li') &#123; // some code &#125;&#125;); (1) 利用事件对象的stopPropagation方法，阻止事件传播 捕获阶段阻止 1234// 事件传播到 p 元素后，就不再向下传播了p.addEventListener('click', function (event) &#123; event.stopPropagation();&#125;, true); 冒泡阶段阻止 1234// 事件冒泡到 p 元素后，就不再向上冒泡了p.addEventListener('click', function (event) &#123; event.stopPropagation();&#125;, false); (2) 利用事件对象的stopImmediatePropagation方法，彻底取消事件，就像没发生一样 stopPropagation方法只能阻止这个事件的传播，不会阻止该事件触发节点的其他相同事件的监听函数。 123456789p.addEventListener('click', function (event) &#123; event.stopImmediatePropagation(); console.log(1);&#125;);p.addEventListener('click', function(event) &#123; // 不会被触发 console.log(2);&#125;); (3) 事件代理优缺点 优点 减少事件注册，节省内存。比如， 在table上代理所有td的click事件。 在ul上代理所有li的click事件。 简化了dom节点更新时，相应事件的更新。比如 不用在新添加的li上绑定click事件。 当删除某个li时，不用移解绑上面的click事件。 缺点 事件委托基于冒泡，对于不冒泡的事件不支持。 层级过多，冒泡过程中，可能会被某层阻止掉。 理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在table上代理td，而不是在document上代理td。 把所有事件都用代理就可能会出现事件误判。比如，在document中代理了所有button的click事件，另外的人在引用改js时，可能不知道，造成单击button触发了两个click事件。 四、EventTarget 接口 DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 该接口主要提供三个实例方法： addEventListener：绑定事件的监听函数 removeEventListener：移除事件的监听函数 dispatchEvent：触发事件 (1) target.addEventListener(type, listener[, useCapture]); EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。 12var btn = document.getElementById('btn');btn.addEventListener('click', doSomething, false); 该方法接受三个参数。 type：事件名称，大小写敏感。 listener：监听函数。事件发生时，会调用该监听函数。 useCapture：(可选)布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。 关于参数，有两个地方需要注意。 第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象。 12345btn.addEventListener('click', &#123; handleEvent: function (event) &#123; console.log('click'); &#125;&#125;); 其次，第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。 capture：布尔值，表示该事件是否在捕获阶段触发监听函数。 once：布尔值，表示监听函数是否只触发一次，然后就自动移除。 passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。123element.addEventListener('click', function (event) &#123; // 只执行一次的代码 &#125;, &#123;once: true&#125;); 监听函数内部的this，指向当前事件所在的那个对象 1234var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; this === btn // true&#125;, false); (2) EventTarget.removeEventListener() EventTarget.removeEventListener方法用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。 12div.addEventListener('click', listener, false);div.removeEventListener('click', listener, false); removeEventListener方法的参数，必须与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。 (3) EventTarget.dispatchEvent() EventTarget.dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。 该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。 dispatchEvent方法的参数是一个Event对象的实例 123para.addEventListener('click', hello, false);var event = new Event('click');para.dispatchEvent(event); 五、Event 对象 事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。 (1) Event对象本身就是一个构造函数，可以用来生成新的实例。 1let event = new Event(type, options); Event构造函数接受两个参数 type： 是字符串，表示事件的名称 options： 是一个对象，表示事件对象的配置。该对象主要有下面两个属性。 bubbles：布尔值，可选，默认为false，表示事件对象是否冒泡。 cancelable：布尔值，可选，默认为false，表示事件是否可以被取消，即能否用Event.preventDefault()取消这个事件。 注意，如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数。 123456789101112131415// HTML 代码为// &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;var div = document.querySelector('div');var p = document.querySelector('p');function callback(event) &#123; var tag = event.currentTarget.tagName; console.log('Tag: ' + tag); // 没有任何输出&#125;div.addEventListener('click', callback, false);var click = new Event('click');p.dispatchEvent(click);div.dispatchEvent(click); 上面代码中，监听函数不会触发。如果写成div.addEventListener('click', callback, true)，才可以在“捕获阶段”监听到这个事件。 另一方面，如果这个事件在div元素上触发: div.dispatchEvent(click)。因为这时div元素是事件的目标，不存在是否冒泡的问题，div元素总是会接收到事件，因此导致监听函数生效。 (2) 实例属性 属性 值类型 默认值 描述 Event.bubbles 布尔值 false 表示当前事件是否会冒泡 Event.eventPhase 整数常量 0，事件目前没有发生。1，事件目前处于捕获阶段。2，事件到达目标节点。3，事件处于冒泡阶段 表示事件目前所处的阶段 Event.cancelable 布尔值 false 表示事件是否可以取消，当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件该，属性只读。 Event.cancelBubble 布尔值 false Event.stopPropagation() 以前的别名。 Event.defaultPrevented 布尔值 false 表示该事件是否调用过Event.preventDefault方法。该属性只读。 Event.currentTarget dom节点对象 null 返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。 Event.target dom节点对象 null 返回原始触发事件的那个节点 Event.type 字符串 生成事件的时候指定的值 表示事件类型。该属性只读。 Event.timeStamp 数值 返回一个毫秒时间戳 表示事件发生的时间。它是相对于网页加载成功开始计算的。 Event.isTrusted 布尔值 false 表示该事件是否由真实的用户行为产生。 Event.detail 数值 - 属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。 (3) 实例方法 Event.preventDefault： 方法取消浏览器对当前事件的默认行为。 stopPropagation： 方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。 Event.stopImmediatePropagation： 方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比Event.stopPropagation()更彻底。 Event.composedPath： 返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。 参考 https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture https://developer.mozilla.org/zh-CN/docs/Web/API/Event https://wangdoc.com/javascript/events/index.html https://zhuanlan.zhihu.com/p/26536815]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[观察者模式与发布/订阅模式]]></title>
    <url>%2F2019%2F03%2F25%2F13-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[发布/订阅模式 和 观察者模式 是非常相似的，也有不少文章将这两个模式统称为观察者模式。 观察者模式 核心组件： 目标基类: 维护观察者列表，以便添加、移除和通知observers(观察者)； 观察者基类: 提供一个更新接口，当目标实例发出通知后，进行调度； JS代码实现 观察者列表基类 1234567891011121314151617181920class ObserverList &#123; constructor() &#123; this.observerList = []; &#125; add(observer) &#123; // todo add observer to list return this.observerList.push(observer) &#125; remove(observer) &#123; // todo remove observer from list var index = this.observerList.indexOf(observer) if (index !== -1) &#123; this.observerList.splice(index, 1) &#125; &#125; count() &#123; // return observer list size return this.observerList.length &#125;&#125; 目标基类 1234567891011121314151617181920class Subject &#123; constructor() &#123; this.observers = new ObserverList(); &#125; addObserver(observer) &#123; // todo add observer this.observers.add(observer) &#125; removeObserver(observer) &#123; // todo remove observer this.observers.remove(observer) &#125; notify(...args) &#123; // todo notify var observerCount = this.observers.count(); for (var i = 0; i &lt; observerCount; i++) &#123; this.observers.observerList[i].update(...args); &#125; &#125;&#125; 观察者基类 12345class Observer &#123; update() &#123; // ... &#125;&#125; 运作 1234let subject = new Subject(); // 目标实例let ob = new Observer(); // 观察者实例subject.addObserver(ob); // 注册subject.notify() // 通知观察者，调度update 总结 目标基类提供维护观察者的一系列方法，观察者基类提供更新接口； 观察者和目标继承各自的基类； 然后具体观察者把自己注册到具体目标里，在目标发生变化时候，调度观察者的更新方法； 目标对象和观察者对象相互绑定，一个目标可以有多个观察者，同时一个观察者可以观察多个目标。 吐槽 一开始了解观察者模式，就被这名字给误导了。这哪门子算是观察，观察给人感觉应该是一个主动的过程，观察者主动观察到变化，调度自己的更新方法，那还差不多。而上面明明是目标主动发出通知，调度各“观察者”的更新方法，“观察者”是被动接收的通知，所以叫响应者还差不多。像“气象台发出气象通知，各媒体响应报道”。 发布/订阅模式 和上面不同，发布/订阅模式囊括在一个对像内。 核心组件： 发布/订阅基类: 维护订阅列表，以便添加或移除订阅和发布通知。 JS代码实现 1234567891011121314151617181920212223242526272829class PubSub &#123; constructor() &#123; this.subscribers = &#123;&#125;; // 订阅列表 &#125; subscribe(type, fn) &#123; // todo subscribe this.subscribers[type] = this.subscribers[type] || [] this.subscribers[type].push(fn) return this.subscribers[type] &#125; unsubscribe(type, fn) &#123; // todo unsubscribe var sub = this.subscribers[type] if (!sub) return var idx = sub.indexOf(fn) sub.splice(idx, 1) &#125; publish(type, ...args) &#123; // todo publish var sub = this.subscribers[type] if (!sub) return sub.forEach(fn =&gt; &#123; fn(...args) &#125;); &#125;&#125; 运作 123let ob = new PubSub(); // 发布订阅实例ob.subscribe('target', update); // 把订阅者和目标，注册到订阅列表ob.publish('target'); // 发布者通知目标变化，调度目标订阅者 结论 订阅者把自己和订阅的目标注册到订阅列表； 当目标发生变化，发布者发布通知，调度目标订阅者； 两种模式的优缺点 优点 鼓励我们认真思考应用程序不同部分之间的关​​系。将应用程序分解为更小，使耦合松散，以改善代码管理和重用的潜力。 缺点 这些模式的一些问题实际上源于它们的主要好处。在发布/订阅中，通过将发布者与订阅者分离，有时可能难以保证程序的特定部分是正常运行的，使代码不好理解及代码不好维护等等。 参考 学习JavaScript设计模式: https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript 观察者与发布/订阅模式之间的差异: https://www.cnblogs.com/lovesong/p/5272752.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript自动化集成测试]]></title>
    <url>%2F2019%2F03%2F22%2F12-%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[首先声明一点，前端开发的单元测试并不是在前端的开发过程中所必须的。但是随着每个工程的复杂化、代码的高复用性要求和前端代码模块之间的高内聚低耦合的需求，前端工程中的单元测试流程就显得很有必要。 BDD和TDD BDD： Behavior Driven Development,行为驱动开发是一种敏捷软件开发的技术，它鼓励软件项目中的开发者，QA和非技术人员之间的协作。 TDD： Test-Driven Development,就是测试驱动开发，它是一种测试先于编写代码的思想用于指导软件开发，测试驱动开发是敏捷开发中的一项核心时间和技术，也是一种设计方法论，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码 工具介绍 测试框架 所谓&quot;测试框架&quot;，就是运行测试的工具。 Mocha： 兼容不同风格断言库，支持测试用例分组，同步异步测试架构，生命周期钩子。mocha既可以基于 Node.js环境运行，也可以在浏览器环境运行。 Jasmine： 略 断言库 Mocha本身不带断言库，所以必须先引入断言库。 assert： TDD风格断言，是nodejs的一个断言测试模块，提供的api不是很多 should.js： BDD风格断言库，should相对于assert有比较丰富的api，并且其语法非常的语义化 expect： BDD风格断言，语法和should.js类似 chai： 支持BDD/TDD双模式，同时支持should/expect/assert三种风格的断言库，还有强大的插件机制 测试工具 karma： 能够模拟各种环境来运行你的测试代码，比如Chrome，Firefox，mobile等等。 持续集成（CI）服务 持续集成是指只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期后，再将新代码&quot;集成&quot;到主干。 Travis CI： 可以绑定Github上面的项目，只要有新的代码，就会自动抓取。然后提供一个运行环境，执行测试，完成构建，还能部署到服务器。 Demo01 (mocha + chai) 安装相关依赖 12cnpm i -g mochacnpm i -Dmocha chai 断言库 chai 的三种断言风格 assert 12var assert = chai.assert;assert.typeOf(foo, 'string'); should 12chai.should();foo.should.be.a('string'); expect 12var expect = chai.expect;expect(foo).to.be.a('string'); // 判断字符串类型 创建test/test.js文件，代码： 12345678910const expect = require('chai').expect; // 引入function add(x,y)&#123; return x+y; &#125;;describe('a add() function test',()=&gt;&#123; // describe 创建测试套件 it('1+1=2',()=&gt;&#123; // it 创建测试用例 expect(add(1,1)).to.be.equal(2); // expect 创建断言，判断相等 &#125;) it('-1+1=0',()=&gt;&#123; expect(add(-1,1)).to.be.equal(0) &#125;)&#125;) 运行测试： 终端：mocha test.js 如果文件夹包含 test 目录，mocha 会自动测试 test下所有测试模块：mocha 如果 test 目录下还有子目录，则递归测试：mocha --recursive 查看所以的测试报告可用格式：mocha --reporters 测试同时生成报告文档：mocha --recursive --reporter [doc] 12345// 默认报告格式a add() function test √ 1+1=2 √ -1+1=0 2 passing (9ms) 更加友好的报告： 安装为全局依赖：cnpm i -g mochawesome 安装到目录的开发依赖：cnpm i -D mochawesome； 生成由 mochawesome 定义的报告格式：mocha --recursive --reporter mochawesome 异步测试： 模拟异步测试用例-代码： 123456789101112const expcet = require("chai").expect;describe("async test suite", () =&gt; &#123; it('模拟异步测试用例', done =&gt; &#123; let b = false; function foo() &#123; b = true; expcet(b).to.be.ok; done() &#125; setTimeout(foo, 3000); &#125;)&#125;) 执行: mocha 报错：Error: Timeout of 2000ms exceeded… 原因：执行超时, mocha默认超时时间是2s 解决：mocha -t 5000 //延长超时时间 Demo2 (mocha + should.js + karma + travis ci) 安装相关依赖 12345npm install -D mochanpm install -D shouldnpm install -D karmanpm install -D karma-chrome-launchernpm install -D karma-mocha should.js 基本断言 123foo.should.be(); bar.should.have();foo.should.bot.be(); 创建src/main.js文件，代码： 123function add(x, y) &#123; return x + y;&#125; 创建test/test.js文件，代码： 12345describe('add', function () &#123; it('8 + 8 = 16', function () &#123; add(8, 8).should.equal(16); &#125;)&#125;) 配置karma（karma.conf.js） 终端： 1karma init 按提示操作生成karma.conf.js配置 1234561. Which testing framework do you want to use ? (mocha)2. Do you want to use Require.js ? (no)3. Do you want to capture any browsers automatically ? (Chrome)4. What is the location of your source and test files ? (&apos;node_modules/should/should.js&apos;, &apos;test/**/*.js&apos;, &apos;src/**/*.js&apos;)5. Should any of the files included by the previous patterns be excluded ? ()6. Do you want Karma to watch all the files and run the tests on change ? (yes) 值得注意的字段 singleRun 如果值为 true, 则在浏览器运行完测试后会自动退出关闭浏览器窗口。 browsers 浏览器配置(可以配置多个浏览器); 如果浏览器无法启动需要进行相关浏览器的配置。 关于karma的更多配置：http://karma-runner.github.io/3.0/config/configuration-file.html 运行测试 1karma start karma会运行chrome浏览器，并且输出测试结果 接入 travis ci 修改 karma.conf.js 配置 1singleRun:!!process.env.TRAVIS // travis环境测试完自动关闭浏览器 配置travis（.travis.yml） 12345678language: node_jsnode_js: - 10before_install: - npm installbefore_script: - &quot;export DISPLAY=:99.0&quot; - &quot;sh -e /etc/init.d/xvfb start&quot; 把项目Demo2上传到github 通过GitHub登录 travis-ci 的官网：www.travis-ci.org/ 同步并激活监听github上的Demo2项目 此时可以在travis上查看测试反馈]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中操作符new做了哪些事情]]></title>
    <url>%2F2019%2F03%2F11%2F11-NEW%E7%9A%84%E4%BA%8B%E6%83%85%2F</url>
    <content type="text"><![CDATA[JS原型, 原型链的本质, 重新梳理一下。(纯属个人理解) 示例 1234567891011function Iaaing() &#123; this.qqName = "tom" this.reset = function (name) &#123; this.qqName = name return this.qqName &#125; window.self = this return "a fun"&#125;Iaaing.prototype.age = 18Iaaing.job = "engineer" Iaaing 是一个函数, 也是一个构造函数, 还是一个对象(万物皆对象) Iaaing 是函数 众所周知，它可以函数式调用 1Iaaing() // a fun 内部的this指向 window 1self === window // true 尝试访问属性 1234Iaaing.qqName // undefinedself.qqName // tomvar name = self.reset("jerry")self.qqName === name // true 结论： 当执行了Iaaing()后，this指向window全局，但是并没有创建实例，只是在window实例下添加了相应属性和方法。 与其说它是函数，还不如说是全局对象 window 的一个方法 其中Iaaing.qqName并没有报错，说明Iaaing也是一个对象，可以通过输出{Iaaing}查看； 可以理解成这样： 123456789101112window = &#123; Iaaing:function()&#123; this.qqname="tom" &#125;&#125;window.Iaaing()// window = &#123;// Iaaing:function()&#123;// this.qqName = "tom"// &#125;,// qqName = "tom"// &#125; Iaaing 是构造函数 构造函数配合操作符new，能生产出实例 1var jkm = new Iaaing 这样jkm成为Iaanig的实例，探究一下构造函数的数据结构 可以看出，构造函数和普通的对象的区别就是，它声明完毕后就带上一个复杂的属性：prototype 里面包含了：Iaaing.prototype.constructor === Iaaing 查看this指向 1self === jkm // true new 做的事情：在构造函数Iaaing调用过程中把this指向jkm 看看实例jkm的数据结构 实例jkm除了本身定义的属性，还多了一个__proto__的东西。 通过下面的验证，得知实例的__proto__，就是构造函数的原型(prototype) 1jkm.__proto__ === Iaaing.prototype // true 实例可以继承构造函数的原型，体现在实例的__proto__属性 1jkm.constructor === Iaaing // true jkm实例对象本身没有constructor属性，但是通过继承Iaaing的原型，可以在__proto__里拿到constructor属性 尝试访问属性 1234jkm.qqName // tomjkm.age // 18jkm.job // undefinedIaaing.age // undefined 很显然，jkm经过实例之后，只有属性qqName和age能在对象的直接属性或者一层层的原型链__proto__里找到 构造函数定义在哪里? 先来看个示例，首先函数对象实际是存储在内存中，A和B只不过是指向内存的变量 12function A()&#123; this.w = "a" &#125;function B()&#123; this.w = "b" &#125; 函数A的原型里有个叫构造函数的东西指向的是A，所以A本身就是构造函数 1A.prototype.contructor === A // true 这里就有个问题了，当我们使用new的时候，调用的是A.prototype.contructor还是A本身呢？ 1234var t1 = new A // &#123; w:"a" &#125;A.prototype.contructor = B // ƒ B()&#123; this.w = "b" &#125;var t2 = new A // &#123; w:"a" &#125;A // ƒ A()&#123; this.w = "a" &#125; 通过上面验证，即使使A.prototype.contructor = B，当使用new的时候，就是调用函数A本身，也就是new做的事情：A.call(this) 推出结论：构造函数就是通过变量声明的函数本身 结论：new 做了哪些事 模拟声明 function Iaaing(){} 的过程 123456789window:&#123; Iaaing: // ƒ() &#123; prototype : &#123; constructor : Iaaing; &#125; __proto__ : Function.prototype &#125;&#125; 创建新的空对象: var jkm = {} ; Iaaing 的原型对象的构造函数构造 jkm 时，jkm 会自动继承的原型对象: jkm = { __proto__: Iaaing.prototype } ; 调用 Iaaing 的构造函数，把 this 指向 jkm，也就是Iaaing.call(jkm); 返回新对象地址，保存到变量 jkm 中 补充 构造函数里的return 在JavaScript构造函数中： 如果return原始类型，那么对构造函数没有影响，实例化对象返回空对象； 12345function A()&#123; return "jkm"&#125;var a = new Aa instanceof A // true 如果return引用类型（数组，函数，对象），那么实例化对象就会返回该引用类型。 123456function B()&#123; return [1,2,3]&#125;var a = new Ba instanceof B // falsea instanceof Array // true 刨根挖底 谁是最终的构造函数? 12345678910function A()&#123;&#125; var a = new Aa.constructor === A // true A.constructor === Function //true A既是a的构造函数又是Function的实例Function.constructor === Function // true Function的构造函数是它本身Object.constructor === Function // true Array.constructor === Function // true String.constructor === Function // true Number.constructor === Function // true ... 说明一切对象最终的构造函数都是Function，当new Function()生产一个构造函数对象时，就会自动获得prototype属性，并成为下一个new它产生的构造函数 谁是最终的原型? 12345678910111213function A()&#123;&#125; var a = new Aa.__proto__ === A.prototype //trueA.prototype.__proto__ === Object.prototype //trueObject.prototype.__proto__ === null //trueA.__proto__ === Function.prototype //trueFunction.prototype.__proto__ === Object.prototype //trueObject.prototype.__proto__ === null //trueFunction.__proto__ === Function.prototype //trueFunction.prototype.__proto__ === Object.prototype //trueObject.prototype.__proto__ === null //true 说明一切对象最终的原型都是Object.prototype，除了Object.create(null) 图解Function和Object 的关系]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序二叉树]]></title>
    <url>%2F2019%2F03%2F09%2F10-%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树是一种数据结构，通过比较数据的重要性，让数据像树杈一样呈现。然后利用二叉树的特性对数据进行排序，其效率比起冒泡排序高得多。 概念 某个节点最多有两个子节点的树。常用于排序。效率较高。 节点中的值：键, key。 兄弟节点：拥有同一个父节点的节点。 根节点：没有父节点 叶子节点: 没有子节点。 中间节点: 有子节点。 高：节点都有深度，最大的节点深度即为这棵树的高。 排序二叉树：节点左孩子的值小于它，右孩子的值大于它。显然，左子树的节点值都比当前节点小，右子树的逗比当前节点大。 通过javascript实现二叉树结构 需求 新建一个空的二叉树: var binaryTree = new BinaryTree();; 插入新的节点: binaryTree.insert(key) 思路 确定单个节点属性： this.key 当前节点key值 this.left 指向左子节点 this.right 指向右子节点 提供插入节点的方法 12345678910111213141516171819202122232425262728293031function BinaryTree() &#123; var Node = function (key) &#123; this.key = key; this.left = null; this.right = null; &#125; var root = null; var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; if (node.left === null) &#123; node.left = newNode &#125; else &#123; insertNode(node.left, newNode) &#125; &#125; else &#123; if (node.right === null) &#123; node.right = newNode &#125; else &#123; insertNode(node.right, newNode) &#125; &#125; &#125; this.insert = function (key) &#123; var newNode = new Node(key); if (root === null) &#123; root = newNode &#125; else &#123; insertNode(root, newNode) &#125; &#125;&#125; 遍历二叉树节点 思路：使用递归遍历 中序遍历 遍历顺序：左子节点（树）-&gt;当前节点-&gt;右子节点（树） 升序访问每一个节点 12345678910var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; inOrderTraverseNode(node.left, callback) callback(node.key); inOrderTraverseNode(node.right, callback) &#125;&#125;this.inOrderTraverse = function (callback) &#123; inOrderTraverseNode(root, callback)&#125; 前序遍历 遍历顺序：当前节点-&gt;左子节点（树）-&gt;右子节点（树） 适合进行排序二叉树的复制，效率比创建一棵同样的二叉树高 1234567891011var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key) preOrderTraverseNode(node.left, callback) preOrderTraverseNode(node.right, callback) &#125;&#125;this.preOrderTraverse = function (callback) &#123; preOrderTraverseNode(root, callback)&#125; 后序遍历 遍历顺序：左子节点（树）-&gt;右子节点（树）-&gt;当前节点； 适合进行文件系统的遍历。 1234567891011var postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback) postOrderTraverseNode(node.right, callback) callback(node.key) &#125;&#125;this.postOrderTraverse = function (callback) &#123; postOrderTraverseNode(root, callback)&#125; 二叉树节点的查找 最小值 思路：根据二叉树的性质，查找二叉树中最左的节点； 123456789101112var minNode = function (node) &#123; if (node) &#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left &#125; console.log(node.key) &#125; return null&#125;this.min = function () &#123; minNode(root)&#125; 最大值 思路：相当于查找二叉树中最右的节点 123456789101112var maxNode = function (node) &#123; if (node) &#123; while (node &amp;&amp; node.right !== null) &#123; node = node.right &#125; console.log(node.key) &#125; return null&#125;this.max = function () &#123; maxNode(root)&#125; 指定值 思路：比较节点的key值，决定向左或向右查找 12345678910111213141516var searchNode = function (node, key) &#123; while (node) &#123; if (node.key === key) &#123; return node &#125; if (node.key &lt; key) &#123; node = node.right &#125; else &#123; node = node.left &#125; &#125; return null&#125;this.search = function (key) &#123; return searchNode(root, key)&#125; 二叉树节点的删除 思路1: 简化，单考虑叶子节点的删除 找到目标节点node, 使 node = null 使目标节点的父节点, 指向 left/right = null 1234567891011121314151617181920var removeNode = function (node, key) &#123; if (node === null) &#123; return null &#125; if (key &lt; node.key) &#123; node.left = removeNode(node.left, key) return node // 返回当前节点，以便找到目标后递归返回的时候可以满足：node.left = node.left.left &#125; else if (key &gt; node.key) &#123; node.right = removeNode(node.right, key) return node &#125; else &#123; if (node.left === null &amp;&amp; node.right === null) &#123; node = null return node &#125; &#125;&#125;this.remove = function (key) &#123; return removeNode(root, key)&#125; 思路2: 加入中间节点的删除 要删除的目标节点下包含一个子节点left or right 使目标节点等于子节点 要删除的目标节点下包含两个子节点left and right 查询目标节点的右子节点的最左节点key, 使其等于目标节点的key 删除目标节点的右子节点的最左节点 123456789101112131415161718192021222324252627282930313233var removeNode = function (node, key) &#123; if (node === null) &#123; return null &#125; if (key &lt; node.key) &#123; node.left = removeNode(node.left, key) return node // 返回当前节点，以便找到目标后递归返回的时候可以满足：node.left = node.left.left &#125; else if (key &gt; node.key) &#123; node.right = removeNode(node.right, key) return node &#125; else &#123; if (node.left === null &amp;&amp; node.right === null) &#123; node = null return node &#125; // 加入中间节点的删除, start if (node.left === null) &#123; node = node.right return node &#125; else if (node.right === null) &#123; node = node.left return node &#125; var aux = findMinNdde(node.right) node.key = aux.key node.right = removeNode(node.right, aux.key) return node // 加入中间节点的删除, end &#125;&#125;this.remove = function (key) &#123; return removeNode(root, key)&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[koa 入门]]></title>
    <url>%2F2018%2F09%2F09%2F09-Koa%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 在 node &lt; 7.6 版本的 Koa 中使用 ES7 async 方法 安装shell 12npm install --save koacnpm install babel babel-register babel-preset-env --save 配置入口文件 app.js 12require(&quot;babel-register&quot;)require(&apos;./server.js&apos;) 配置 .babelrc 文件 12345678&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;targets&quot;: &#123; &quot;node&quot;: true &#125; &#125; ]]&#125; Koa 入门，配置 server.js 123456var koa = require(&apos;koa&apos;);var app = new koa();app.use(async(ctx, next) =&gt; &#123; ctx.body = &apos;hello koa&apos;&#125;);app.listen(8080);]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript之异步控制]]></title>
    <url>%2F2018%2F08%2F04%2F08-JS%E5%BC%82%E6%AD%A5%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[就基于javascript技术，做一些总结，以方便快速开发。 ES6 Promise 12345678var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 可以链式调用：promise().then().catch() 虽然Promise解决了深度回调的问题，但是却无法避免代码的层叠嵌套😲。 ES7 async/await async顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成。并且await只能在async函数中使用。 通常async、await都是跟随Promise一起使用的。为什么这么说呢？因为async返回的都是一个Promise对象同时async适用于任何类型的函数上。而await紧跟一个Promise直接是取得异步的结果。 1234async function dosth()&#123; let response = await promise&#125;dosth() async、await也使用到了Promise但是却减少了Promise的then处理使得整个异步请求代码优雅了许多。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 配置]]></title>
    <url>%2F2018%2F07%2F03%2F07-webpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 vue + webpack 打造todo应用 依赖版本参考 vue-loader+webpack项目配置 12345//package.json"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build":"webpack --config webpack.config.js",&#125; 123456789101112131415161718192021&lt;!-- app.vue --&gt;&lt;template&gt; &lt;div class="text"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; text:'jkm' &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.text&#123; color: aqua; margin-left:50px;&#125;&lt;/style&gt; 12345678910//index.jsimport Vue from 'vue'import App from './app.vue'const root = document.createElement('div')document.body.appendChild(root)new Vue(&#123; render:(h)=&gt;h(App)&#125;).$mount(root) 12345678910111213141516171819202122// webpack.config.jsconst path = require('path') const config = &#123; //入口路径 entry: path.join(__dirname, 'src/index.js'), //出口路径 output: &#123; filename: 'bundle.js', path: path.join(__dirname, 'dist') &#125;, //由于webpack本身只支持js和es5的语法，不理解vue语法，为此在rules下新增规则 module: &#123; rules: [ &#123; test: /\.vue$/, loader: 'vue-loader' &#125; ] &#125;,module.exports = config webpack配置项目加载各种静态资源及css预处理器 123456789101112131415161718192021222324252627&#123; test: /\.css$/, use: [ 'style-loader', //把css代码以js的方式写到html里面 'css-loader' //读取css文件的样式 ]&#125;,&#123; test: /\.(gif|jpg|jpeg|png|svg)$/, use: [ &#123; loader: 'url-loader', //把图片转换成base64格式，写在出口文件bundle.js里 options: &#123; limit: 1024, //限制图片的大小 name: '[name]-jkm.[ext]' //输出图片的名字 &#125; &#125; ]&#125;,&#123; test: /\.styl/, use: [ 'style-loader', 'css-loader', 'stylus-loader' ]&#125; webpack-dev-server的配置和使用 12345678//package.json1、设置环境变量 NODE_ENV = productio/development；2、为适应不同平台（windows、linux、mac...），利用cross-env来帮助读取。"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build":"cross-env NODE_ENV=production webpack --config webpack.config.js", "dev":"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js"&#125; 12345678910111213141516171819202122232425262728293031323334353637// webpack.config.jsconst path = require('path') const HTMLPlugin = require('html-webpack-plugin') //帮助生成html文件，并且自动包含bundle.jsconst webpack = require('webpack')const isDev = process.env.NODE_ENV === 'development' //NODE_ENV保存在process.env对象中const config = &#123; target:'web' //设置编译目标为web平台 ... plugins: [ //可以让webpack编译过程中，以及自己的js代码中，调用 process.env.NODE_ENV 来判断环境 new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: isDev ? '"development"' : '"production"' &#125; &#125;), new HTMLPlugin() ]&#125;if (isDev) &#123; config.devtool = "#cheap-module-eval-source-map" //帮助在浏览器调试代码，把webpack编译后的代码，通过代码的映射，转换成自己的代码。 config.devServer = &#123; // port: 8000, //端口 host: '0.0.0.0', //能同时通过localhost、127.0.0.1、本机内网IP访问 overlay: &#123; //可以把webpack编译过程中出现的错误，显示到网页中 errors: true, &#125;, hot: true, //修改代码中数据保存后，只会重新渲染修改组件的数据，不会让整个页面重新加载。 open:true //自动打开浏览器 &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), //使支持hot功能 new webpack.NoEmitOnErrorsPlugin() //减少不需要信息的展示的问题 )&#125;module.exports = config]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex 入门]]></title>
    <url>%2F2018%2F06%2F02%2F06-vuex%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 安装 1npm i vuex -S 使用 123456789101112131415// store.js 声明import Vuex from 'vuex'import defaultState from './state/state'import mutations from './mutations/mutations'import getters from './getters/getters'export default ()=&gt;&#123; return new Vuex.Store(&#123; strict: true, // 使通过 this.$store.state.count=3 修改值，会报错，开发模式下使用 state:defaultState, // 数据状态 mutation, // 保存数据同步方法 getters, // 类似vue中的computed actions, // 保存数据异步方法 &#125;)&#125; 123456789// 引用import createStore from './store/store'Vue.use(Vuex)const store = createStore()...// 使用this.$store.state.count //statethis.$store.commit('方法名', param) //mutationsthis.$store.dispatch('方法名', param) //actions 同时vuex，提供了便捷的方法，可在vue中定义 1234567891011121314import &#123; mapState, mapGetters, mapActions, mapMutations&#125; from 'vuex'...computed:&#123; ...mapState(['count']), //同名 ...mapState(&#123; counter:'count', counter:(state) =&gt; state.count &#125;), ...mapGetters(['同名方法名'])&#125;methods:&#123; ...mapActions(['同名方法名']) ...mapMutations(['同名方法名'])&#125; Vuex 模块化 123456789101112131415161718192021222324252627282930313233343536// store.js...&#123; modules:&#123; a:&#123; namespaced: true, // 默认false，会把mutations下方法定义到全局 state:&#123; text: 1 &#125;, mutations:&#123; updateText(state,text)&#123; state.text = text &#125; &#125;, getters:&#123; textPlus(state, getter, rootState)&#123; // 通过rootState可以获取全局的数据 return state.text + rootState.count + rootState.b.text &#125; &#125;， actions:&#123; add(&#123; state, commit, rootState&#125;)&#123; commit('updateText', rootState.count) commit('updateCount', rootState, &#123;root:true&#125;) // 通过 root:true 使模块可以调用全局的方法 &#125; &#125; &#125;, b:&#123; state:&#123; text: 2 &#125; &#125; &#125;&#125;...vue中调用this.$store.state.a.text //1this.$store.state.b.text //2......mapMutations(['a/updateText'])...mapMutations(&#123; updataText: state =&gt; state.a.updateText&#125;) 扩展 使支持ES最新的语法 1cnpm i babel-preset-stage-1 -D]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Createjs 入门]]></title>
    <url>%2F2018%2F05%2F02%2F05-Createjs%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[CreateJS是基于HTML5开发的一套模块化的库和工具。 基于这些库，可以非常快捷地开发出基于HTML5的游戏、动画和交互应用。 CreateJS主要包含如下四个类库： EaselJS – 简化处理HTML5画布（核心） TweenJS – 用来帮助调整HTML5和Javascript属性 SoundJS – 用来简化处理HTML5 audio PreloadJS – 帮助管理和协调加载中的一些资源 Demo源码: https://github.com/iaaiNG/CreateJs EaselJS EaselJS 是一个JavaScript库,用来简单快捷的操作 HTML5 Canvas 标签。在创建H5游戏，生成艺术作品、处理其他高级图形化等工作中有着很友好的体验。 容器 Stage 和 Container Stage是root级容器的显示列表, 区别于Container, 都可以承载各种集成自DisplayObject的类如Shape和Container, 通过update方法将图形渲染在canvas上。 12345678\\ 创建舞台let stage = new createjs.Stage("canvas") \\ 创建Text实例let text = new createjs.Text("hello easeljs","36px Arial","#777")\\ 将Text实例添加到舞台stage.addChild(text);\\ 渲染canvasstage.update() 基础方法 — DisplayObject methods parameters type returns description addChild(child) DisplayObject (child) DisplayObject 将DisplayObject实例添加到显示列表 addChildAt(child, index) DisplayObject; Number (child) DisplayObject 将DisplayObject实例添加到显示列表指定位置 基础属性 — DisplayObject properties type default description children Array null 容器显示列表的数组集合 alpha Number 1 透明度0~1 x Number 0 容器绘制原点的x坐标 y Number 0 容器绘制原点的y坐标 绘制图形 Shape + Graphics 创建一个Shape实例, 一个可以承载各种图形的DisplayObject对象, 它的graphics属性是Graphics对象的暴露了所有图形方法。 123456var graphics = new createjs.Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);var shape = new createjs.Shape(graphics);//或者可以利用Shape类上的graphics的原型方法, 渲染出与上面一样的效果var shape = new createjs.Shape();shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100); 图形方法 — Graphics methods parameters type returns description beginFill(color) string Graphics实例本身 指定填充的颜色 beginStroke(color) string Graphics实例本身 指定描边的颜色 endFill() \ Graphics实例本身 等同于 beginFill(null) endStroke() \ Graphics实例本身 等同于 beginStroke(null) drawRect (x, y, w, h) Number Graphics实例本身 绘制矩形 setStrokeStyle(thickness) Number Graphics实例本身 设置描边宽度 drawCircle (x, y, radius) Number Graphics实例本身 绘制圆形 lineTo(x, y) Number Graphics实例本身 绘制路径 moveTo(x, y) Number Graphics实例本身 移动绘制原点到指定点 closePath() \ Graphics实例本身 闭合当前路径 事件 事件绑定方式 1234567891011121314displayObject.addEventListener("click", handleClick);function handleClick(event) &#123; // Click happened.&#125;var listener = myBtn.on("click", handleClick, null, false, &#123;count:3&#125;); function handleClick(evt, data) &#123; data.count -= 1; console.log(this == myBtn); // true - scope defaults to the dispatcher if (data.count == 0) &#123; alert("clicked 3 times!"); myBtn.off("click", listener); // 或者利用 evt.remove() 移除事件监听 &#125; &#125; 事件方法 — DisplayObject methods parameters type returns description addEventListener(type, listener, [事件冒泡]) String, Function\Object, Boolean listener 添加指定事件监听 removeEventListener(type, listener, [事件冒泡]) String, Function\Object, Boolean \ 移除指定事件监听 removeAllEventListeners ( [type] ) String \ 移除所有事件或者指定类型的所有事件监听 on(type, listener, [scope], [once=false], [data], [useCapture=false] ) String, Function\Object ,Object, Boolean, params, Boolean listener 添加事件监听快捷方式 off(type, listener, [事件冒泡]) String, Function\Object, Boolean \ 移除指定事件监听快捷方式 hasEventListener(type) String false/true 检查是否监听指定事件 事件类型 event description click 单击 dblclick 双击 mousedown 按下 mouseout 离开目标范围(默认禁用, 需要设置enableMouseOver属性启用) mouseover 进入目标范围(默认禁用, 需要设置enableMouseOver属性启用) pressmove 按下移动 pressup 松开按下 tick 舞台更新时触发 断续器 Ticker Class Ticker是一个静态类，提供了好多静态方法和属性，不要去实例化它。 属性 properties type default description framerate Number \ 帧率 timingMode String Ticker.TIMEOUT 指定计时API和模式(setTimeout\requestAnimationFrame) CreateJs 提供了两种渲染模式，一种是用 setTimeout ，一种是用 requestAnimationFrame ，默认是 setTimeout ，默认的帧数是 20 ，一般的话还没有什么区别，但是如果动画多的话，设置成 requestAnimationFrame 模式的话，就会感觉到动画如丝般的流畅。 1createjs.Ticker.timingMode = createjs.Ticker.RAF; 文本绘制 Text Class 1var text = new createjs.Text("Hello World", "20px Arial", "#ff7700"); 方法 methods parameters type returns description getMeasuredHeight() \ 文本测量的高度值 获取文本的近似高度 getMeasuredWidth() \ 文本测量的宽度值 获取文本的近似宽度 属性 properties type default description color String \ 字体颜色(ex. “#fff”) font String \ 字体样式(ex. “bold 36px Arial”) lineHeight Number \ 字体行高 lineWidth Number \ 字体行宽 text String \ 文本内容 textAlign String left 文本水平对齐方式(right start end center) outline Number \ 指定描边粗细显示字体 图像绘制 Bitmap Class 图片, 视频, 乃至canvas, 都可以添加到Bitmap Class的显示列表上。 注意: 需要图片加载完成后, 再来更新舞台, 才能让图片显示。 12345var bitmap = new createjs.Bitmap("imagePath.jpg");// 或者var img = new Image()img.src = "image.jpg"var bitmap = new createjs.Bitmap(img) 影片剪辑 MovieClip Class 1234567891011121314var stage = new createjs.Stage('canvas')createjs.Ticker.timingMode = createjs.Ticker.RAF;createjs.Ticker.addEventListener('tick', stage)var prop = &#123; labels: &#123; start: 50 &#125;, loop: true&#125;var mc = new createjs.MovieClip(prop)stage.addChild(mc)var state1 = new createjs.Shape(new createjs.Graphics().beginFill('#123').drawCircle(0, 100, 30))var state2 = new createjs.Shape(new createjs.Graphics().beginFill('#555').drawCircle(0, 100, 30))mc.timeline.addTween( createjs.Tween.get(state1).to(&#123; x: 30 &#125;).to(&#123; x: 370 &#125;, 100).to(&#123; x: 30 &#125;, 100) )mc.timeline.addTween( createjs.Tween.get(state2).to(&#123; x: 370 &#125;).to(&#123; x: 30 &#125;, 100).to(&#123; x: 370 &#125;, 100) )mc.gotoAndPlay("start") 精灵 Sprite Class Sprite继承自DisplayObject, 可以显示来自SpriteSheet的实例， SpriteSheet Class封装了相关的API和属性, 利用一帧帧图像拼凑的图, 来生成精灵动态图。 传递给SpriteSheet构造函数的数据定义: images: 图像url。 frames: 单帧图像的位置。 animations: 命名动画名的帧序列, 可选。 framerate: 目标播放帧率FPS,可选。 1234567891011121314151617181920var stage = new createjs.Stage('canvas')var ss = new createjs.SpriteSheet(&#123; images:["./img/spritesheet_grant.png"], frames:&#123; height: 292.5, width: 165.75, count:64 &#125;, animations:&#123; run:[0,25,"jump",1.5], jump:[26,63,"run"] &#125;&#125;)var s = new createjs.Sprite(ss, "run")stage.addChild(s)createjs.Ticker.timingMode = createjs.Ticker.RAF;createjs.Ticker.addEventListener('tick', stage) Dom元素 DOMElement Class DOMElement可以将HTMLElement转换成DisplayObject对象(不完整), 因此它可以被添加到舞台。然而, 它并没有被渲染到画布上。 12345var domElement = new createjs.DOMElement(htmlElement);\\ DOMElement实例不是完整的EaselJS显示对象，要从DOMElement获取鼠标事件，您必须向htmlElement添加处理程序。domElement.htmlElement.onclick = function() &#123; console.log("clicked");&#125; TweenJS TweenJS Javascript库提供了一个简单但功能强大的tweening接口。它支持数值对象属性和CSS样式属性的渐变，并允许链式调用，以创建复杂的动画。 TweenJs Class Tweens属性作用于单个目标，方法链式调用以创建复杂的动画序列 Example: 1234createjs.Tween.get(target) .wait(500) .to(&#123;alpha:0, visible:false&#125;, 1000) .call(handleComplete); get(target, [props]) 返回一个新的tween实例。这在功能上与使用new Tween(…)是相同的，但是使用TweenJS的链式语法看起来更整洁。 Parameters: target | Object tween 目标 [props] | Object optional 应用于此实例的配置属性(例如{loop:-1, pause:true})。支持的常用可选属性如下所示: properties parameters type description [loop=0] Boolean Number 循环次数，设置为true，则永久循环 [reversed=false] Boolean 反向播放 [timeScale=1] Number 播放倍率 [paused=false] Boolean 暂停或取消暂停 [onChange] Function 添加change事件 [override=false] Boolean optional 当设置为true时, 移除目标现有Tween操作 to(props, [duration=0], [ease=“linear”]) 改变目标指定属性值, 并在定义时间内渐变去显示。 Example 1createjs.Tween.get(target).to(&#123;alpha:0, visible:false&#125;, 1000); 方法 Methods methods parameters type returns description label(name) String Tween实例 添加一个标签, 可以供gotoAndPlay/gotoAndStop使用 wait ｜Number Tween实例 添加一个等待时间 pause Tween Tween实例 添加暂停指定Tween的操作 Ease Class Ease类提供了一系列用于TweenJS的Ease函数。 大多数关于Ease的方法可以直接作为easing函数传递: 1createjs.Tween.get(target).to(&#123;x:100&#125;, 500, createjs.Ease.linear); 有关Ease类型的概述，访问: https://www.createjs.com/#demos/tweenjs/tween_sparktable 运动指南插件 MotionGuidePlugin Class 用于自定义对象的运动轨迹 要在TweenJS加载完成, 然后安装插件使用 1createjs.MotionGuidePlugin.install(); Example 1234// Using a Motion Guide 用法createjs.Tween.get(target).to(&#123;guide:&#123; path:[0,0, 0,200,200,200, 200,0,0,0] &#125;&#125;,7000);// Visualizing the line 可视化路径graphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>createjs</tag>
        <tag>easeljs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5 之 canvas]]></title>
    <url>%2F2018%2F04%2F08%2F04-H5%E4%B9%8Bcanvas%2F</url>
    <content type="text"><![CDATA[Canvas 是 HTML5 新增的，一个可以使用脚本(通常为JavaScript)在其中绘制图像的 HTML 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。 canvas标签 123&lt;canvas width="500" height="400"&gt; 您的浏览器版本太低，请更新!&lt;/canvas&gt; canvas标签在浏览器中默认300*150的inline-block 画布的宽度和高只能使用html/js属性来赋值 画笔对象 1var ctx = canvas.getContext("2d"); 每个画布上有且只有一个“画笔”对像，该对象进行绘图 Main API API 描述 ctx.lineWidth = 1 描边宽度(空心) ctx.fillStyle = “#000” 填充样式/颜色(实心) ctx.strokeStyle=“red” 描边样式(空心) tx.fillRect(x,y,w,h) 填充一个矩形 ctx.clearRect(x,y,w,h) 清除一个矩形范围内所有绘图 矩形绘制 API 描述 ctx.strokeRect(x,y,w,h) 描边一个矩形 文本绘制 API 描述 ctx.textBaseline = “top/bottom/alphabetic” #文本基线:(垂直对齐方式) ctx.font = “12px sans-serif” 字体大小和字体 ctx.fillText(str,x,y) 填充一段文本 ctx.strokeText(str,x,y) 描边一段文本 ctx.measureText(str) 测量文本宽度,返回对象{width:x} 添加渐变对象 线性渐变:linearGradient 径向渐变:radialGradient 创建渐变对象 1var g = ctx.createLinearGradient(x1,y1,x2,y2); 设置颜色点 123g.addColorStop(0,"blue");g.addColorStop(0.5,"red");g.addColorStop(1,"green"); 将渐变对象应用填充或描边样式 12ctx.fillStyle = g;ctx.strokeStyle = g; 路径绘制 Path：由多个坐标点组成任意形状,路径不见，可用于&quot;描边&quot;，“填充”，“裁剪”; API 描述 ctx.beginPath() 开始一条新路径 ctx.closePath() 闭合当前路径 ctx.moveTo(x,y) 移动指定点 ctx.lineTo(x,y) 从当前点到指定点画一条直线 ctx.arc(cx,cy,r,start,end) 绘制圆拱形路径 ctx.stroke() 对当前路径描边 ctx.fill() 对当前路径填充 ctx.clip() 对当前路径裁剪 图像绘制 canvas属于客户端技术，图片在服务器上，所以浏览器必须先下载绘制图片，且等待图片加载成功后再绘制图片 123456var p3 = new Image(); //1:创建图片对象p3.src = "img/p3.png"; //2:发送请求并且下载图片p3.onload = function()&#123; //3:图片下载完成，触发事件onload ctx.drawImage(p3,x,y); //原始大小绘图 ctx.drawImage(p3,w,y,w,h); //拉伸绘图&#125; 变形操作 Canvas绘图中也变形技术，可以针对一个图像/图形绘制过程进行变形, rotate; translate; API 描述 ctx.rotate(弧度) 旋转绘图对象，轴点画布原点(0,0) ctx.translate(x,y) 整个画布的原点平移到指定的点 ctx.save() 保存画笔所有变形状态值 ctx.restore() 恢复画布变形状态值到最近一次保存]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 实用技巧]]></title>
    <url>%2F2018%2F03%2F06%2F03-css%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[好记性不如烂笔头，能写下来的绝对不会记的&lt;(￣︶￣)&gt;，这里专门收录一些CSS常用的小技巧 文本溢出显示省略号 单行 123overflow:hidden;text-overflow:ellipsis;white-space:nowrap 多行 只有-webkit内核才有作用 12345overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 属性 作用 -webkit-line-clamp 用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中 display: -webkit-box 将对象作为弹性伸缩盒子模型显示 -webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。 text-overflow: ellipsis 以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。 实现文字两端对齐 写法一（缺点兼容性差） 1234567div &#123; width: 100px; border: 1px solid red; text-align: justify; text-align-last: justify; text-justify: distribute;&#125; 写法二（引入伪类） text-align: justify; 属性可单独使用，前提是文本需要超过两行，不过最后一行不会两边对齐。因此如果是单行，可使用 hack 来“伪造”最后一行，以达到单行视觉上的两边对齐效果。 123456789div&#123; width:500px; text-align: justify;&#125;div:after &#123; content: " "; display: inline-block; width: 100%;&#125; CSS 移动端适配 利用手机淘宝，rem适配方案 https://github.com/amfe/lib-flexible 安装 1npm i -S amfe-flexible 嵌入网页 1&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"&gt;&lt;script src="./node_modules/amfe-flexible/index.js"&gt;&lt;/script&gt; 了解rem和em rem是基于html元素的字体大小来决定，而em则根据使用它的元素的大小决定 使用 em 单位的唯一原因是缩放没有默认字体大小的元素，比如按钮，菜单和标题可能会有自己明确的字体大小。当你修改字体大小的时候，希望整个组件都适当缩放]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础]]></title>
    <url>%2F2018%2F02%2F07%2F02-CSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[css全称叫Cascading Style Sheet，可译为“层叠样式表”或“级联样式表”，用于控制Web页面的外观。通过使用CSS样式设置页面的格式，可将页面的内容与表现形式分离。 CSS的语法规范 使用方式 内联方式: 1&lt;div style="background:red;"&gt;&lt;/div&gt; 内部样式表: 12345&lt;style&gt; .container&#123; background: blue; &#125;&lt;/style&gt; 外部样式表 1&lt;link rel="stylesheet" href="index.css"&gt; 特征 继承性 大部分的css效果是可以直接继承给子元素的。 层叠性 一个元素定义多个样式规则，规则中的属性不冲突时，可以同时都应用到当前元素上。 优先级 在层叠性基础上，如果样式声明冲突的话,则按照默认的优先级去应用样式。 浏览器默认设置 样式表(内外部) 就近原则 - 后定义者优先 内联方式 !important 优先级由低到高 选择器 selectors syntax 通用选择器 * { } 元素选择器 div { } 类选择器 .class-name { } ID选择器 #id-name { } 群组选择器 div, .class-name, #id-anme { } 后代选择器 #id-anme .class-name div { } 子代选择器 .class-name&gt;div { } selectors syntax description 伪类选择器 a:link { } 匹配元素a尚未被访问时候的状态 a:visited { } 匹配元素a访问过的状态 :hover { } 鼠标悬停时的效果 :active { } 鼠标保持按下时的状态 :focus { } 获取焦点时的状态 单位 尺寸单位 px, in(英寸), pt(磅), cm, mm, em, rem 颜色单位 rgb, rgba, #rrggbb(位十六进制的数字), #rgb(缩写), yellow... 尺寸 语法 attribute description width 宽度 min-width 最小宽度 max-width 最大宽度 height 高度 min-height 最小高度 max-height 最大高度 允许设置尺寸的元素 所以块级元素 部分行内块元素: radio, checkbox 本身具备width, height的元素 溢出处理 attribute value description overflow overflow-x overflow-y visible 默认值，溢出可见 hidden 溢出隐藏 scroll 显示滚动条，溢出可用 auto 溢出时才显示滚动条 边框 attribute value description border width style color 边框 border-top/right/bottom/left width style color 单边框 border-radius px, % 边框倒角 box-shadow边框阴影 h-shadow *阴影的水平偏移距离 v-shadow *阴影的垂直偏移距离 blur 模糊距离 spread 边框属性阴影的大小，指定要在基础阴影上扩充出来的大小距离 color 阴影颜色 inset 内阴影 outline width style color; none/0 为取消轮廓 轮廓 框模型]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git管理]]></title>
    <url>%2F2018%2F01%2F05%2F01-Git%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 配置 修改自己的用户名和邮箱地址 12git config --global user.name&quot;xxx&quot;git config --global user.email &quot;xxx&quot; 查看配置 1git config --list 理论 工作区域（Working Directory）就是你平时存放项目代码的地方。 暂存区域（Stage）用于临时存放你的改动，事实上它只是一个文件，保存即将提交的文件列表信息。 Git 仓库（Repository）就是安全存放数据的位置，这里边有你提交的所有版本的数据。其中，HEAD 指向最新放入仓库的版本。 Git 管理的文件有三种状态：已修改（modified）、已暂存（staged）和已提交（committed） Ex: 将工作目录的文件放到 Git 仓库 12git add .git commit -m [message] or more simple 1git commit -am [message] 查看信息 order description git status 显示有变更的文件 git log 显示当前分支的版本历史 git reflog 显示当前分支的最近几次提交，包括已经被reset删除的 git diff 显示暂存区和工作区的代码差异 git diff [快照ID] [快照ID] 显示两个快照之间的差异 git diff [快照ID] 显示工作区和快照之间的差异 git diff --cached [快照ID] 显示暂存区和快照之间的差异 git log 可添加 --oneline 只一行显示 --graph 图形化显示 --all 显示所有分支 Stage 与 Working Directory 之间增加 / 删除文件 order description git add [file1] [file2] … 添加指定文件到暂存区 git rm [file1] [file2] … 删除工作区文件，并且将这次删除放入暂存区 git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区 代码提交 order description git commit -m [message] 提交暂存区到仓库区 git commit --amend -m [message] 使用一次新的commit，替代上一次提交 撤销 order description git checkout – [file] 恢复暂存区的指定文件到工作区 git reset HEAD [file] 清空add命令向暂存区提交的关于file文件的修改 git reset HEAD~n 移动HEAD的指向，将其指向上n个快照HEAD；然后再将该位置的快照回滚到暂存区域。 git reset --soft HEAD~ 只移动HEAD的指向，但并不会将快照回滚到暂存区域 git reset --hard HEAD~ 不仅移动HEAD的指向，将快照回滚动到暂存区域，还将暂存区域的文件还原到工作目录 git reset xxxxxx 回滚到指定快照 分支 实际开发中的分支管理 常设分支就主分支（master）和开发分支（develop） 临时分支有功能分支（feature）、预发布分支（release）和维护分支（hotfix），用完之后应该及时删除 order description git branch [branch-name] 新建一个分支，但依然停留在当前分支 git checkout [branch-name] 切换到指定分支，并更新工作区 git checkout -b [branch] 新建一个分支，并切换到该分支 git branch -d [branch-name] 删除分支 git checkout --orphan [branch] 基于当前所在分支新建一个赤裸裸的分支，没有任何的提交历史 git merge [branc 合并指定分支到当前分支 远程同步 order description git remote show [remote] 显示某个远程仓库的信息 git remote add [shortname] [url] 增加一个新的远程仓库，并命名 git pull [remote] [branch] 取回远程仓库的变化，并与本地分支合并 git push [remote] [branch] 上传本地指定分支到远程仓库]]></content>
      <categories>
        <category>管理工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
